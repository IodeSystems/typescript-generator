package com.iodesystems.ts

import com.iodesystems.ts.lib.ts
import java.io.File
import kotlin.test.Test
import kotlin.test.assertTrue

/**
 * This test reproduces the "doomsday scenario" that caused the refactor:
 * - API controller lives in com.external.core.api (from test-project:test-core)
 * - Types used by the API live in com.external.dep.models (from test-project:test-dep)
 * - These packages are NOT on the direct compile classpath, only on the override classpath
 *
 * The TypeScript generator must:
 * 1. Discover the API methods in UserController via overrideClasspath
 * 2. Extract types from com.external.dep.models even though they're not in the API package
 * 3. Generate correct TypeScript for all external types including:
 *    - Simple data classes (User, UserPreferences)
 *    - Enums (UserRole)
 *    - Generic types (Page<T>)
 *    - Polymorphic/sealed types (ApiResult<T>)
 */
class ExternalClassPathTest {

    private fun getExternalClasspath(): List<String> {
        // Read the classpath from the file generated by test-project:test-core:writeClasspath
        // Tests run from core/ directory, so go up one level to find test-project
        val projectRoot = File("..").canonicalFile
        val classpathFile = File(projectRoot, "test-project/test-core/build/classpath.txt")

        assertTrue(classpathFile.exists(), "classpath.txt should exist at ${classpathFile.absolutePath}")

        return classpathFile.readLines().filter { it.isNotBlank() }
    }

    @Test
    fun `generates TypeScript for API using external package types`() {
        val externalJars = getExternalClasspath()

        val output = TypeScriptGenerator.build {
            // Use override classpath to load types from external jars
            classPathUrls { externalJars }
            // Only include the API package - types should be discovered from external dep
            packageAccept("com.external.core.api.UserController")
        }.generate()

        val ts = output.ts()
        println("Generated TypeScript:\n$ts")

        // Verify the API class is generated
        assertTrue(
            ts.contains("export class UserController"),
            "UserController API should be generated"
        )

        // Verify external types are extracted
        assertTrue(
            ts.contains("export type User =") || ts.contains("type User ="),
            "User type from external package should be generated"
        )

        assertTrue(
            ts.contains("export type UserPreferences =") || ts.contains("type UserPreferences ="),
            "UserPreferences type from external package should be generated"
        )

        // Verify enum is extracted
        assertTrue(
            ts.contains("UserRole") && (ts.contains("ADMIN") || ts.contains("\"ADMIN\"")),
            "UserRole enum from external package should be generated"
        )

        // Verify generic Page type is extracted
        assertTrue(
            ts.contains("Page<") || ts.contains("Page ="),
            "Page<T> generic type from external package should be generated"
        )

        // Verify polymorphic ApiResult type is extracted
        assertTrue(
            ts.contains("ApiResult") || ts.contains("ApiResultUnion"),
            "ApiResult<T> polymorphic type from external package should be generated"
        )

        // Verify Success/Failure variants are extracted
        assertTrue(
            ts.contains("Success") && ts.contains("Failure"),
            "ApiResult.Success and ApiResult.Failure should be generated"
        )

        // Verify API methods use the external types
        assertTrue(
            ts.contains("getUser") && ts.contains("User"),
            "getUser method should reference User type"
        )

        assertTrue(
            ts.contains("listUsers") && ts.contains("Page"),
            "listUsers method should reference Page type"
        )

        assertTrue(
            ts.contains("createUser"),
            "createUser method should be generated"
        )

        assertTrue(
            ts.contains("updatePreferences"),
            "updatePreferences method should be generated"
        )

        assertTrue(
            ts.contains("deleteUser"),
            "deleteUser method should be generated"
        )
    }

    @Test
    fun `external types have correct field structure`() {
        val externalJars = getExternalClasspath()

        val output = TypeScriptGenerator.build {
            classPathUrls { externalJars }
            packageAccept("com.external.core.api.UserController")
        }.generate()

        val ts = output.ts()

        // User should have all its fields
        assertTrue(
            ts.contains("id:") || ts.contains("id :"),
            "User type should have id field"
        )
        assertTrue(
            ts.contains("name:") || ts.contains("name :"),
            "User type should have name field"
        )
        assertTrue(
            ts.contains("email:") || ts.contains("email :"),
            "User type should have email field"
        )

        // Page should have pagination fields
        assertTrue(
            ts.contains("items:") || ts.contains("items :"),
            "Page type should have items field"
        )
        assertTrue(
            ts.contains("page:") || ts.contains("page :"),
            "Page type should have page field"
        )
        assertTrue(
            ts.contains("totalItems") || ts.contains("total"),
            "Page type should have totalItems field"
        )
    }

    @Test
    fun `polymorphic types from external package are correctly handled`() {
        val externalJars = getExternalClasspath()

        val output = TypeScriptGenerator.build {
            classPathUrls { externalJars }
            packageAccept("com.external.core.api.UserController")
        }.generate()

        val ts = output.ts()

        // ApiResult should be a union type
        assertTrue(
            ts.contains("ApiResultSuccess") || ts.contains("Success"),
            "ApiResult.Success variant should be generated"
        )
        assertTrue(
            ts.contains("ApiResultFailure") || ts.contains("Failure"),
            "ApiResult.Failure variant should be generated"
        )

        // Success should have data field
        assertTrue(
            ts.contains("data:") || ts.contains("data :"),
            "Success variant should have data field"
        )

        // Failure should have error and code fields
        assertTrue(
            ts.contains("error:") || ts.contains("error :"),
            "Failure variant should have error field"
        )
        assertTrue(
            ts.contains("code:") || ts.contains("code :"),
            "Failure variant should have code field"
        )

        // Both should have requestId
        assertTrue(
            ts.contains("requestId"),
            "ApiResult variants should have requestId field"
        )
    }
}
